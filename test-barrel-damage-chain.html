<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test: Barrel Damage Chain Reaction</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #2c3e50;
            color: white;
            font-family: Arial, sans-serif;
        }
        #game-container {
            border: 2px solid #34495e;
            margin: 20px auto;
            display: block;
        }
        .info {
            max-width: 800px;
            margin: 0 auto;
            text-align: center;
        }
        .controls {
            background: #34495e;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
        .status {
            background: #27ae60;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .buttons {
            background: #e74c3c;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
        .buttons button {
            background: #c0392b;
            color: white;
            border: none;
            padding: 10px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        .buttons button:hover {
            background: #a93226;
        }
        .log {
            background: #2c3e50;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            height: 150px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 11px;
            text-align: left;
        }
    </style>
</head>
<body>
    <div class="info">
        <h1>üß™ Test: Barrel Damage Chain Reaction</h1>
        <p>Prueba del sistema de da√±o en cadena - los barriles se da√±an entre s√≠</p>
        
        <div class="controls">
            <h3>Concepto:</h3>
            <p><strong>üõ¢Ô∏è Barriles con HP:</strong> Cada barril tiene vida (1-3 HP)</p>
            <p><strong>üí• Explosi√≥n da√±a:</strong> Cuando explota, DA√ëA a barriles cercanos</p>
            <p><strong>üîó Cadena autom√°tica:</strong> Si el da√±o reduce HP a 0, explota autom√°ticamente</p>
            <p><strong>üéØ Estrategia:</strong> Encuentra grupos de barriles para m√°ximo efecto</p>
        </div>

        <div class="buttons">
            <h3>Configuraciones de Prueba:</h3>
            <button onclick="createLineFormation()">üìè L√≠nea de Barriles</button>
            <button onclick="createClusterFormation()">üéØ Grupo Compacto</button>
            <button onclick="createMixedHealthFormation()">‚ù§Ô∏è HP Variado</button>
            <button onclick="clearAll()">üóëÔ∏è Limpiar Todo</button>
        </div>

        <div class="status">
            <p><strong>Barriles:</strong> <span id="barrels">0</span> | <strong>HP Total:</strong> <span id="totalHP">0</span> | <strong>Explosiones:</strong> <span id="explosions">0</span></p>
        </div>

        <div class="log" id="log">
            <div>üîç Log de da√±o en cadena:</div>
        </div>
    </div>

    <div id="game-container"></div>

    <script>
        // Variables globales
        let player, cursors, scene;
        let bullets = [];
        let barrels = [];
        let explosionCount = 0;
        let shootTimer = 0;

        // Configuraci√≥n del juego
        const config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            parent: 'game-container',
            backgroundColor: '#1a252f',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        function preload() {
            // No necesitamos cargar assets externos
        }

        function create() {
            scene = this;
            
            // Crear jugador
            player = this.add.rectangle(100, 300, 20, 20, 0x3498db);
            this.physics.add.existing(player);
            player.body.setCollideWorldBounds(true);

            // Crear controles
            cursors = this.input.keyboard.createCursorKeys();

            // Crear formaci√≥n inicial
            createLineFormation();

            // Actualizar UI
            updateStatus();
            logEvent('üéÆ Sistema de da√±o en cadena iniciado');
            logEvent('üí° Dispara al primer barril para iniciar la cadena');
        }

        function createLineFormation() {
            clearAll();
            
            // L√≠nea de 6 barriles con 1 HP cada uno
            for (let i = 0; i < 6; i++) {
                const barrel = createBarrel.call(scene, 250 + i * 80, 300, 1, `L√≠nea-${i + 1}`);
                barrels.push(barrel);
            }

            logEvent(`üìè L√çNEA: Creados ${barrels.length} barriles en l√≠nea (1 HP cada uno)`);
            logEvent('üéØ Dispara al primer barril para ver la cadena completa');
            updateStatus();
        }

        function createClusterFormation() {
            clearAll();
            
            // Grupo compacto de barriles
            const positions = [
                { x: 400, y: 250, hp: 1, label: 'Centro' },
                { x: 350, y: 280, hp: 1, label: 'Izq-1' },
                { x: 450, y: 280, hp: 1, label: 'Der-1' },
                { x: 380, y: 320, hp: 1, label: 'Izq-2' },
                { x: 420, y: 320, hp: 1, label: 'Der-2' },
                { x: 400, y: 350, hp: 1, label: 'Abajo' }
            ];

            positions.forEach(pos => {
                const barrel = createBarrel.call(scene, pos.x, pos.y, pos.hp, pos.label);
                barrels.push(barrel);
            });

            logEvent(`üéØ GRUPO: Creados ${barrels.length} barriles en formaci√≥n compacta`);
            logEvent('üí• Una explosi√≥n deber√≠a activar m√∫ltiples barriles');
            updateStatus();
        }

        function createMixedHealthFormation() {
            clearAll();
            
            // Barriles con diferentes HP para mostrar el sistema de da√±o
            const positions = [
                { x: 200, y: 200, hp: 3, label: 'Fuerte-1' },
                { x: 280, y: 220, hp: 2, label: 'Medio-1' },
                { x: 360, y: 200, hp: 1, label: 'D√©bil-1' },
                { x: 440, y: 220, hp: 2, label: 'Medio-2' },
                { x: 520, y: 200, hp: 1, label: 'D√©bil-2' },
                { x: 600, y: 220, hp: 3, label: 'Fuerte-2' }
            ];

            positions.forEach(pos => {
                const barrel = createBarrel.call(scene, pos.x, pos.y, pos.hp, pos.label);
                barrels.push(barrel);
            });

            logEvent(`‚ù§Ô∏è HP VARIADO: Creados barriles con 1-3 HP`);
            logEvent('üî• Los barriles fuertes necesitan m√∫ltiples explosiones');
            updateStatus();
        }

        function createBarrel(x, y, health, label) {
            // Crear barril visual con color basado en HP
            let color = 0x8b4513; // Marr√≥n base
            if (health === 1) color = 0xcd853f; // Marr√≥n claro (d√©bil)
            if (health === 2) color = 0x8b4513; // Marr√≥n normal (medio)
            if (health === 3) color = 0x654321; // Marr√≥n oscuro (fuerte)

            const barrel = this.add.rectangle(x, y, 24, 24, color);
            barrel.setStrokeStyle(3, 0x2f1b14);
            
            // Agregar f√≠sica
            this.physics.add.existing(barrel, true);
            
            // Propiedades del barril
            barrel.health = health;
            barrel.maxHealth = health;
            barrel.isDestructible = true;
            barrel.type = 'explosive_barrel';
            barrel.label = label;

            // Elementos visuales adicionales
            const topRing = this.add.rectangle(x, y - 7, 26, 3, 0x654321);
            const bottomRing = this.add.rectangle(x, y + 7, 26, 3, 0x654321);
            
            // S√≠mbolo de peligro
            const warning = this.add.triangle(x, y - 2, 0, -8, -7, 6, 7, 6, 0xffff00);
            warning.setStrokeStyle(1, 0xff8800);
            
            // Texto con HP
            const hpText = this.add.text(x, y + 4, `${health}HP`, {
                fontSize: '8px',
                color: '#ff0000',
                fontStyle: 'bold'
            }).setOrigin(0.5);

            // Efecto de parpadeo
            this.tweens.add({
                targets: [warning, hpText],
                alpha: 0.6,
                duration: 1000,
                yoyo: true,
                repeat: -1
            });

            barrel.additionalElements = [topRing, bottomRing, warning, hpText];
            barrel.hpText = hpText; // Referencia para actualizar HP
            return barrel;
        }

        function update(time, delta) {
            // Mover jugador
            if (cursors.left.isDown) {
                player.body.setVelocityX(-200);
            } else if (cursors.right.isDown) {
                player.body.setVelocityX(200);
            } else {
                player.body.setVelocityX(0);
            }

            if (cursors.up.isDown) {
                player.body.setVelocityY(-200);
            } else if (cursors.down.isDown) {
                player.body.setVelocityY(200);
            } else {
                player.body.setVelocityY(0);
            }

            // Disparo autom√°tico hacia barriles
            shootTimer += delta;
            if (shootTimer >= 600) {
                shootTimer = 0;
                autoShoot.call(this);
            }

            // Actualizar balas
            updateBullets.call(this);

            // Verificar colisiones
            checkCollisions.call(this);
        }

        function autoShoot() {
            if (barrels.length === 0) return;

            // Encontrar barril m√°s cercano
            let closestBarrel = null;
            let closestDistance = Infinity;

            barrels.forEach(barrel => {
                const distance = Phaser.Math.Distance.Between(
                    player.x, player.y, barrel.x, barrel.y
                );
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestBarrel = barrel;
                }
            });

            if (closestBarrel) {
                shootBullet.call(this, player.x, player.y, closestBarrel.x, closestBarrel.y);
            }
        }

        function shootBullet(fromX, fromY, toX, toY) {
            const bullet = this.add.rectangle(fromX, fromY, 6, 6, 0xf1c40f);
            this.physics.add.existing(bullet);

            const angle = Phaser.Math.Angle.Between(fromX, fromY, toX, toY);
            const speed = 400;

            bullet.body.setVelocity(
                Math.cos(angle) * speed,
                Math.sin(angle) * speed
            );

            bullets.push(bullet);
        }

        function updateBullets() {
            bullets = bullets.filter(bullet => {
                if (bullet.x < -50 || bullet.x > 850 || bullet.y < -50 || bullet.y > 650) {
                    bullet.destroy();
                    return false;
                }
                return true;
            });
        }

        function checkCollisions() {
            bullets.forEach((bullet, bulletIndex) => {
                barrels.forEach((barrel, barrelIndex) => {
                    if (Phaser.Math.Distance.Between(bullet.x, bullet.y, barrel.x, barrel.y) < 20) {
                        logEvent(`üéØ Bala golpea ${barrel.label} (${barrel.health}/${barrel.maxHealth} HP)`);
                        
                        // Remover bala
                        bullet.destroy();
                        bullets.splice(bulletIndex, 1);

                        // Da√±ar barril
                        damageBarrel.call(this, barrel, barrelIndex, 1);
                    }
                });
            });
        }

        function damageBarrel(barrel, barrelIndex, damage) {
            if (barrel.health <= 0) return;

            const previousHealth = barrel.health;
            barrel.health = Math.max(0, barrel.health - damage);

            // Actualizar texto de HP
            if (barrel.hpText) {
                barrel.hpText.setText(`${barrel.health}HP`);
                if (barrel.health === 0) {
                    barrel.hpText.setColor('#ff0000');
                }
            }

            logEvent(`üî• ${barrel.label}: ${previousHealth} ‚Üí ${barrel.health} HP (da√±o: ${damage})`);

            // Efecto visual de da√±o
            this.tweens.add({
                targets: barrel,
                scaleX: 1.2,
                scaleY: 1.2,
                duration: 100,
                yoyo: true
            });

            // Si fue destruido, explotar
            if (barrel.health <= 0) {
                logEvent(`üí• ${barrel.label} DESTRUIDO - iniciando explosi√≥n`);
                explodeBarrel.call(this, barrel, barrelIndex);
            }
        }

        function explodeBarrel(barrel, barrelIndex) {
            const explosionX = barrel.x;
            const explosionY = barrel.y;
            const explosionRadius = 120;

            logEvent(`üí• EXPLOSI√ìN: ${barrel.label} explota en (${Math.round(explosionX)}, ${Math.round(explosionY)})`);

            // Remover barril
            if (barrel.additionalElements) {
                barrel.additionalElements.forEach(element => element.destroy());
            }
            barrel.destroy();
            barrels.splice(barrelIndex, 1);

            // Crear efecto de explosi√≥n
            createExplosionEffect.call(this, explosionX, explosionY, explosionRadius);

            // SISTEMA DE DA√ëO EN CADENA - buscar barriles en radio y DA√ëARLOS
            const barrelsInRange = [];
            barrels.forEach(otherBarrel => {
                const distance = Phaser.Math.Distance.Between(explosionX, explosionY, otherBarrel.x, otherBarrel.y);
                if (distance <= explosionRadius && otherBarrel.health > 0) {
                    barrelsInRange.push(otherBarrel);
                }
            });

            if (barrelsInRange.length > 0) {
                logEvent(`üîó CADENA: ${barrelsInRange.length} barriles en radio de explosi√≥n`);
                
                // Da√±ar barriles con delay para efecto visual
                barrelsInRange.forEach((chainBarrel, index) => {
                    const delay = (index + 1) * 80;
                    logEvent(`üî• Programando da√±o a ${chainBarrel.label} en ${delay}ms`);
                    
                    this.time.delayedCall(delay, () => {
                        const barrelIndex = barrels.indexOf(chainBarrel);
                        if (barrelIndex !== -1 && chainBarrel.health > 0) {
                            // DA√ëAR en lugar de explotar directamente
                            damageBarrel.call(this, chainBarrel, barrelIndex, 1);
                        }
                    });
                });
            } else {
                logEvent(`‚ùå Sin barriles en radio de ${explosionRadius}px`);
            }

            explosionCount++;
            updateStatus();
        }

        function createExplosionEffect(x, y, radius) {
            // Ondas de choque
            for (let wave = 0; wave < 3; wave++) {
                this.time.delayedCall(wave * 50, () => {
                    const shockWave = this.add.circle(x, y, 5, 0xffffff, 0.8 - wave * 0.2);
                    shockWave.setStrokeStyle(3, 0xff4500, 0.9);

                    this.tweens.add({
                        targets: shockWave,
                        radius: radius * (0.8 + wave * 0.3),
                        alpha: 0,
                        duration: 400 + wave * 100,
                        ease: 'Power2',
                        onComplete: () => shockWave.destroy()
                    });
                });
            }

            // Explosi√≥n principal
            const explosion = this.add.circle(x, y, radius * 0.3, 0xff4500, 0.8);
            this.tweens.add({
                targets: explosion,
                scaleX: 2.5,
                scaleY: 2.5,
                alpha: 0,
                duration: 600,
                ease: 'Power3',
                onComplete: () => explosion.destroy()
            });

            // Part√≠culas
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                const distance = 20 + Math.random() * 20;
                const particleX = x + Math.cos(angle) * distance;
                const particleY = y + Math.sin(angle) * distance;

                const particle = this.add.rectangle(particleX, particleY, 4, 4, 0xff6600);
                
                this.tweens.add({
                    targets: particle,
                    x: x + Math.cos(angle) * radius,
                    y: y + Math.sin(angle) * radius,
                    alpha: 0,
                    duration: 500,
                    ease: 'Power2',
                    onComplete: () => particle.destroy()
                });
            }

            this.cameras.main.shake(300, 0.02);
        }

        function clearAll() {
            barrels.forEach(barrel => {
                if (barrel.additionalElements) {
                    barrel.additionalElements.forEach(element => element.destroy());
                }
                barrel.destroy();
            });
            barrels = [];
            explosionCount = 0;
            updateStatus();
            logEvent('üóëÔ∏è Todos los barriles eliminados');
        }

        function updateStatus() {
            const totalHP = barrels.reduce((sum, barrel) => sum + barrel.health, 0);
            document.getElementById('barrels').textContent = barrels.length;
            document.getElementById('totalHP').textContent = totalHP;
            document.getElementById('explosions').textContent = explosionCount;
        }

        function logEvent(message) {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            logDiv.innerHTML += `<div>[${timestamp}] ${message}</div>`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        // Inicializar juego
        const game = new Phaser.Game(config);
    </script>
</body>
</html>